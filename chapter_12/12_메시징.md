## 12.1 메시지 큐
- 메시징 기능의 설계는 메시지를 어떻게 관리할 것이냐 하는 결정에서 시작한다.
- 여기서는 큐를 이용하기로 한다.
- 큐는 가장 일반적이고 효율적인 방법이다.
- 여기서는 배열로 메시지 큐를 구현해 보도록 하겠다.
- /kernel/에 `msg.h`와 `msg.c` 파일을 추가해 주도록 하자.
- 아래는 `msg.h` 이다.
~~~C
#ifndef KERNEL_MSG_H_
#define KERNEL_MSG_H_

#define MSG_Q_SIZE_BYTE 512

typedef enum KernelMsgQ_t
{
    KernelMsgQ_Task0,
    KernelMsgQ_Task1,
    KernelMsgQ_Task2,

    KernelMsgQ_Num
} KernelMsgQ_t;

typedef struct KernelCirQ_t
{
    uint32_t front;
    uint32_t rear;
    uint8_t Queue[MSG_Q_SIZE_BYTE]
} KernelCirQ_t;

void Kernel_msgQ_init(void);
bool Kernel_msgQ_is_empty(KernelMsgQ_t Qname);
bool Kernel_msgQ_is_full(KernelMsgQ_t Qname);
bool Kernel_msgQ_enqueue(KernelMsgQ_t Qname, uint8_t data);
bool Kernel_msgQ_dequeue(KernelMsgQ_t Qname, uint8_t* data);

#endif
~~~
- 큐의 정의에 따라 위에서 선언된 rear에서 데이터를 넣고 front에서 빼도록 한다.
	- rear의 인덱스에 변수가 들어가고, front의 인덱스에 있는 변수의 값을 가져온다.
- 기본으로 512바이트짜리 메시지 큐 세개를 선언했다.
	- 앞에서 선언한 태스크가 3개이기 때문에 한 태스크당 하나의 메시지큐를 선언.
- 다음은 메시지 큐의 전체 코드이다.
~~~C
#include "stdint.h"
#include "stdbool.h"
#include "stdlib.h"

#include "msg.h"

KernelCirQ_t sMsgQ[KernelMsgQ_Num];

void Kernel_msgQ_init(void)
{
    for (uint32_t i = 0 ; i < KernelMsgQ_Num ; i++)
    {
        sMsgQ[i].front = 0;
        sMsgQ[i].rear = 0;
        memclr(sMsgQ[i].Queue, MSG_Q_SIZE_BYTE);
    }
}

bool Kernel_msgQ_is_empty(KernelMsgQ_t Qname)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (sMsgQ[Qname].front == sMsgQ[Qname].rear)
    {
        return true;
    }

    return false;
}

bool Kernel_msgQ_is_full(KernelMsgQ_t Qname)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (((sMsgQ[Qname].rear + 1) % MSG_Q_SIZE_BYTE) == sMsgQ[Qname].front)
    {
        return true;
    }

    return false;
}

bool Kernel_msgQ_enqueue(KernelMsgQ_t Qname, uint8_t data)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (Kernel_msgQ_is_full(Qname))
    {
        return false;
    }
    sMsgQ[Qname].rear++;
    sMsgQ[Qname].rear %= MSG_Q_SIZE_BYTE;

    uint32_t idx = sMsgQ[Qname].rear;
    sMsgQ[Qname].Queue[idx] = data;

    return true;
}

bool Kernel_msgQ_dequeue(KernelMsgQ_t Qname, uint8_t* out_data)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (Kernel_msgQ_is_empty(Qname))
    {
        return false;
    }

    sMsgQ[Qname].front++;
    sMsgQ[Qname].front %= MSG_Q_SIZE_BYTE;

    uint32_t idx = sMsgQ[Qname].front;
    *out_data = sMsgQ[Qname].Queue[idx];

    return true;
}
~~~
- 위의 코드를 보면 큐를 만들고 할당하는 코드와 enqueue, dequeue 등 큐의 연산에 사용하는 코드들로 이루어져 있다.
- `KernelMsgQ_Num`은 msg.h에서 선언한 값으로 3개의 배열을 만든다.
- 기본적인 자료구조이므로 설명은 생략하도록 한다.
- 앞서 태스크나 이벤트와 마찬가지로 커널 API를 이용해 좀 더 사용하기 쉽도록 만들어 보자.
- Kernel.c 파일을 수정한다.
~~~C

bool Kernel_send_msg(KernelMsgQ_t Qname, void* data, uint32_t count)
{
    uint8_t* d = (uint8_t*)data;

    for (uint32_t i=0 ; i < count ; i++)
    {
        if(false == Kernel_msgQ_enqueue(Qname, *d))
        {
            for(uint32_t j = 0 ; j < i ; j++)
            [
                uint8_t rollback;
                Kernel_msgQ_dequeue(Qname, &rollback);
            ]
            return false;
        }
        d++;
    }

    return true;
}

uint32_t Kernel_recv_msg(KernelMsgQ_t Qname, void* out_data, uint32_t count)
{
    uint8_t* d = (uint8_t*)out_data;

    for(uint32_t i=0; i<count ; i++)
    {
        if (false == Kernel_msgQ_dequeue(Qname, d))
        {
            return i;
        }
        d++;
    }
    return count;
}
~~~
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTMxODkyMDcwMSwtMTYzODgzMDI0NywtMT
kzOTIxNjkxNywxMjc4NzIwNDg4LC01NTc1ODQ5NTBdfQ==
-->