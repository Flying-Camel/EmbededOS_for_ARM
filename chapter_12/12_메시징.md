## 12.1 메시지 큐
- 메시징 기능의 설계는 메시지를 어떻게 관리할 것이냐 하는 결정에서 시작한다.
- 여기서는 큐를 이용하기로 한다.
- 큐는 가장 일반적이고 효율적인 방법이다.
- 여기서는 배열로 메시지 큐를 구현해 보도록 하겠다.
- /kernel/에 `msg.h`와 `msg.c` 파일을 추가해 주도록 하자.
- 아래는 `msg.h` 이다.
~~~C
#ifndef KERNEL_MSG_H_
#define KERNEL_MSG_H_

#define MSG_Q_SIZE_BYTE 512

typedef enum KernelMsgQ_t
{
    KernelMsgQ_Task0,
    KernelMsgQ_Task1,
    KernelMsgQ_Task2,

    KernelMsgQ_Num
} KernelMsgQ_t;

typedef struct KernelCirQ_t
{
    uint32_t front;
    uint32_t rear;
    uint8_t Queue[MSG_Q_SIZE_BYTE]
} KernelCirQ_t;

void Kernel_msgQ_init(void);
bool Kernel_msgQ_is_empty(KernelMsgQ_t Qname);
bool Kernel_msgQ_is_full(KernelMsgQ_t Qname);
bool Kernel_msgQ_enqueue(KernelMsgQ_t Qname, uint8_t data);
bool Kernel_msgQ_dequeue(KernelMsgQ_t Qname, uint8_t* data);

#endif
~~~
- 큐의 정의에 따라 위에서 선언된 rear에서 데이터를 넣고 front에서 빼도록 한다.
	- rear의 인덱스에 변수가 들어가고, front의 인덱스에 있는 변수의 값을 가져온다.
- 기본으로 512바이트짜리 메시지 큐 세개를 선언했다.
	- 앞에서 선언한 태스크가 3개이기 때문에 한 태스크당 하나의 메시지큐를 선언.
- 다음은 메시지 큐의 전체 코드이다.
~~~C
#include "stdint.h"
#include "stdbool.h"
#include "stdlib.h"

#include "msg.h"

KernelCirQ_t sMsgQ[KernelMsgQ_Num];

void Kernel_msgQ_init(void)
{
    for (uint32_t i = 0 ; i < KernelMsgQ_Num ; i++)
    {
        sMsgQ[i].front = 0;
        sMsgQ[i].rear = 0;
        memclr(sMsgQ[i].Queue, MSG_Q_SIZE_BYTE);
    }
}

bool Kernel_msgQ_is_empty(KernelMsgQ_t Qname)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (sMsgQ[Qname].front == sMsgQ[Qname].rear)
    {
        return true;
    }

    return false;
}

bool Kernel_msgQ_is_full(KernelMsgQ_t Qname)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (((sMsgQ[Qname].rear + 1) % MSG_Q_SIZE_BYTE) == sMsgQ[Qname].front)
    {
        return true;
    }

    return false;
}

bool Kernel_msgQ_enqueue(KernelMsgQ_t Qname, uint8_t data)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (Kernel_msgQ_is_full(Qname))
    {
        return false;
    }
    sMsgQ[Qname].rear++;
    sMsgQ[Qname].rear %= MSG_Q_SIZE_BYTE;

    uint32_t idx = sMsgQ[Qname].rear;
    sMsgQ[Qname].Queue[idx] = data;

    return true;
}

bool Kernel_msgQ_dequeue(KernelMsgQ_t Qname, uint8_t* out_data)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (Kernel_msgQ_is_empty(Qname))
    {
        return false;
    }

    sMsgQ[Qname].front++;
    sMsgQ[Qname].front %= MSG_Q_SIZE_BYTE;

    uint32_t idx = sMsgQ[Qname].front;
    *out_data = sMsgQ[Qname].Queue[idx];

    return true;
}
~~~
- 위의 코드를 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTIyNzg5MTcyOSwtMTkzOTIxNjkxNywxMj
c4NzIwNDg4LC01NTc1ODQ5NTBdfQ==
-->