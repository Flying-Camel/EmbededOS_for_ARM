## 12.1 메시지 큐
- 메시징 기능의 설계는 메시지를 어떻게 관리할 것이냐 하는 결정에서 시작한다.
- 여기서는 큐를 이용하기로 한다.
- 큐는 가장 일반적이고 효율적인 방법이다.
- 여기서는 배열로 메시지 큐를 구현해 보도록 하겠다.
- /kernel/에 `msg.h`와 `msg.c` 파일을 추가해 주도록 하자.
- 아래는 `msg.h` 이다.
~~~C
#ifndef KERNEL_MSG_H_
#define KERNEL_MSG_H_

#define MSG_Q_SIZE_BYTE 512

typedef enum KernelMsgQ_t
{
    KernelMsgQ_Task0,
    KernelMsgQ_Task1,
    KernelMsgQ_Task2,

    KernelMsgQ_Num
} KernelMsgQ_t;

typedef struct KernelCirQ_t
{
    uint32_t front;
    uint32_t rear;
    uint8_t Queue[MSG_Q_SIZE_BYTE]
} KernelCirQ_t;

void Kernel_msgQ_init(void);
bool Kernel_msgQ_is_empty(KernelMsgQ_t Qname);
bool Kernel_msgQ_is_full(KernelMsgQ_t Qname);
bool Kernel_msgQ_enqueue(KernelMsgQ_t Qname, uint8_t data);
bool Kernel_msgQ_dequeue(KernelMsgQ_t Qname, uint8_t* data);

#endif
~~~
- 큐의 정의에 따라 위에서 선언된 rear에서 데이터를 넣고 front에서 빼도록 한다.
	- rear의 인덱스에 변수가 들어가고, front의 인덱스에 있는 변수의 값을 가져온다.
- 기본으로 512바이트짜리 메시지 큐 세개를 선언했다.
	- 앞에서 선언한 태스크가 3개이기 때문에 한 태스크당 하나의 메시지큐를 선언.
- 다음은 메시지 큐의 전체 코드이다.
~~~C
#include "stdint.h"
#include "stdbool.h"
#include "stdlib.h"

#include "msg.h"

KernelCirQ_t sMsgQ[KernelMsgQ_Num];

void Kernel_msgQ_init(void)
{
    for (uint32_t i = 0 ; i < KernelMsgQ_Num ; i++)
    {
        sMsgQ[i].front = 0;
        sMsgQ[i].rear = 0;
        memclr(sMsgQ[i].Queue, MSG_Q_SIZE_BYTE);
    }
}

bool Kernel_msgQ_is_empty(KernelMsgQ_t Qname)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (sMsgQ[Qname].front == sMsgQ[Qname].rear)
    {
        return true;
    }

    return false;
}

bool Kernel_msgQ_is_full(KernelMsgQ_t Qname)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (((sMsgQ[Qname].rear + 1) % MSG_Q_SIZE_BYTE) == sMsgQ[Qname].front)
    {
        return true;
    }

    return false;
}

bool Kernel_msgQ_enqueue(KernelMsgQ_t Qname, uint8_t data)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (Kernel_msgQ_is_full(Qname))
    {
        return false;
    }
    sMsgQ[Qname].rear++;
    sMsgQ[Qname].rear %= MSG_Q_SIZE_BYTE;

    uint32_t idx = sMsgQ[Qname].rear;
    sMsgQ[Qname].Queue[idx] = data;

    return true;
}

bool Kernel_msgQ_dequeue(KernelMsgQ_t Qname, uint8_t* out_data)
{
    if (Qname >= KernelMsgQ_Num)
    {
        return false;
    }

    if (Kernel_msgQ_is_empty(Qname))
    {
        return false;
    }

    sMsgQ[Qname].front++;
    sMsgQ[Qname].front %= MSG_Q_SIZE_BYTE;

    uint32_t idx = sMsgQ[Qname].front;
    *out_data = sMsgQ[Qname].Queue[idx];

    return true;
}
~~~
- 위의 코드를 보면 큐를 만들고 할당하는 코드와 enqueue, dequeue 등 큐의 연산에 사용하는 코드들로 이루어져 있다.
- `KernelMsgQ_Num`은 msg.h에서 선언한 값으로 3개의 배열을 만든다.
- 기본적인 자료구조이므로 설명은 생략하도록 한다.
- 앞서 태스크나 이벤트와 마찬가지로 커널 API를 이용해 좀 더 사용하기 쉽도록 만들어 보자.
- Kernel.c 파일을 수정한다.
~~~C

bool Kernel_send_msg(KernelMsgQ_t Qname, void* data, uint32_t count)
{
    uint8_t* d = (uint8_t*)data;

    for (uint32_t i=0 ; i < count ; i++)
    {
        if(false == Kernel_msgQ_enqueue(Qname, *d))
        {
            for(uint32_t j = 0 ; j < i ; j++)
            [
                uint8_t rollback;
                Kernel_msgQ_dequeue(Qname, &rollback);
            ]
            return false;
        }
        d++;
    }

    return true;
}

uint32_t Kernel_recv_msg(KernelMsgQ_t Qname, void* out_data, uint32_t count)
{
    uint8_t* d = (uint8_t*)out_data;

    for(uint32_t i=0; i<count ; i++)
    {
        if (false == Kernel_msgQ_dequeue(Qname, d))
        {
            return i;
        }
        d++;
    }
    return count;
}
~~~
- `Kernel_msgQ_enqueue()`가 false를 리턴하면 그 순간부터 큐가 꽉 찼다는 뜻이면서 사용자가 원하는 데이터가 일부는 메시지 큐에 들어가 있고, 일부는 들어가지 못했다는 것을 의미한다. 
- 따라서 이미 메시지 큐에 들어가 있는 불완전한 데이터를 다시 빼내는 작업을 해야만 메시지 큐의 무결성을 보장할 수 있다.
- `false == Kernel_msgQ_dequeue(Qname, d)` 부분은 데이터를 메시지 큐에서 읽는 도중에 메시지 큐에 더 읽을것이 없을 경우 에러를 처리하는 코드이다.
- 만약 그런 경우가 발생하면 현재까지 읽은 바이트 수만 리턴하고 호출하는 쪽에서 알아서 처리하도록 한다.
- 이제 제작한 메시지 큐로 메시지 보내기 및 받기를 하는 커널 API를 추가하도록 해보자.

## 12.2 태스크간 데이터 전달.
- UART 인터럽트 핸들러에서 이벤트와 함께 UART를 통해서 들어온 키보드 입력 값을 메시지 큐로 보내도록 한다.
- Uart.c 파일을 수정해 키보드 입력을 메시지로 보내고 입력이 들어왔다는 신호를 이벤트로 보낸다.
~~~C
Kernel_send_msg(KernelMsgQ_Task0, &ch,1);
Kernel_send_events(KernelEventFlag_UartIn);
~~~
- Task0의 메시지 큐에 UART로 입력받은 값을 전달하고 UartIn 이벤트를 바로 보낸다.
- Task0는 UartIn 이벤트를 기다리고 있다가 이벤트가 발생하면 메시지 큐에서 1바이트를 읽는다.
- Task0는 인터럽트 핸들러에서 이벤트가 오면 메시지 큐에서 1바이트를 읽어서 내부 버퍼에 읽은 값을 게속 쌓아둔다.
- 이제 Mina.c에서 구현하도록 한다.
~~~C
void User_task0(void)
{
    uint32_t local = 0;

    debug_printf("User Task #0 SP=0x%x\n", &local);
    

    while(true)
    {
        KernelEventFlag_t handle_event = Kernel_wait_events(KernelEventFlag_UartIn|KernelEventFlag_CmdOut);
        switch(handle_event)
        {
        case KernelEventFlag_UartIn:
            Kernel_rec_msg(KernelMsgQ_Task0, &uartch, 1);

            if(uartch == '\r')
            {
                cmdBuf[cmdBufIdx] = '\0';

                Kernel_send_msg(KernelMsgQ_Task1, &cmdBufIdx, 1);
                Kernel_send_msg(KernelMsgQ_Task1, cmdBuf, cmdBufIdx);
                Kernel_send_events(KernelEventFlag_CmdIn);

                cmdBufIdx = 0;
            }

            //debug_printf("\nEvent handled by Task0\n");
            break;
        case KernelEventFlag_CmdOut:
            debug_printf("\nCmdOut Event by Task0\n");
            break;
        }
        Kernel_yield();
    }
    ...
~~~
- 핸들러에 들어가게 되면 메시지 큐에서 1바이트를 읽어 uartch 변수에 저장한다.
- 그 다음 엔터가 아니라면 cmdBuf배열에 순서대로 쌓는다.
- 엔터가 입력되면 Task1로 메시지를 보낸다.
	- 먼저 데이터의 길이를 보낸다.
	- 데이터를 보낸다.
- 메시지를 다 보내고 나면 CmdIn 이벤트를 발생시킨다.
- 아직 에러처리를 한 코드가 아니고 flase를 리턴하게 되면 에러 처리를 해 주어야 한다.
- 코드는 아래와 같다.
~~~C
    while(true)
    {
        KernelEventFlag_t handle_event = Kernel_wait_events(KernelEventFlag_UartIn|KernelEventFlag_CmdOut);
        switch(handle_event)
        {
        case KernelEventFlag_UartIn:
            Kernel_rec_msg(KernelMsgQ_Task0, &uartch, 1);

            if(uartch == '\r')
            {
                cmdBuf[cmdBufIdx] = '\0';

                Kernel_send_msg(KernelMsgQ_Task1, &cmdBufIdx, 1);
                Kernel_send_msg(KernelMsgQ_Task1, cmdBuf, cmdBufIdx);
                Kernel_send_events(KernelEventFlag_CmdIn);

                cmdBufIdx = 0;
            }
            else if(false == Kernel_send_msg(KernelMsgQ_Task1, cmdBuf, cmdBufIdx))
            {
                uint8_t rollbakc;
                Kernel_recv_msg(KernelMsgQ_Task1, &rollback, 1);
                Kernel_yield();
            }
            else
            {
                break;
            }
~~~
- 위의 코드를 보면 성공할때까지 재시도 한다.
- 그 이후 아래의 두가지에 따라 처리를 한다.
	- 처음 1바이트로 길이를 보낼때 실패.
	- cmdBuf를 보낼때 실패.
- 첫번째의 경우 아직 데이터를 보내지 않았으므로 `Kernel_yield()`를 호출해 Task1이 메시지 큐를 비우길 기다린 다음 스케줄링이 완료됭면 다시 보낸다.
- 두번째의 경우 길이를 이미 보낸 상황이기 때문에 조금 복잡하다.
- 이럴 경우 Task1의 메시지 큐에서 직전에 보낸 데이터를 뺀다.
	- `Kernel_recv_msg()`를 호출해서 1바이트를 읽어 roolback 변수에 넣는다.
- 이렇게 하면 Task1의 메시지 큐가 문제가 생기기 전으로 돌아간다.
- 그런 다음 다시 `Kernel_yield()` 함수를 호출해서 Task1이 메시지 큐를 비우길 디다리고 같은 작업을 다시 시도한다. 
- `Kernel_send_msg()`가 두번 모두 실행되어야 while문을 빠져나간다. 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc1Mzc0OTM5NCwxNjAwODQ4MDE5LC00OT
c4MTIwMTAsMTQxODE5NTQ3OCwyMTA5NTA4MzUyLC03MzQwNTg0
MTQsMTU1NDEzMjIwNiwtMzE4OTIwNzAxLC0xNjM4ODMwMjQ3LC
0xOTM5MjE2OTE3LDEyNzg3MjA0ODgsLTU1NzU4NDk1MF19
-->