## 12.1 메시지 큐
- 메시징 기능의 설계는 메시지를 어떻게 관리할 것이냐 하는 결정에서 시작한다.
- 여기서는 큐를 이용하기로 한다.
- 큐는 가장 일반적이고 효율적인 방법이다.
- 여기서는 배열로 메시지 큐를 구현해 보도록 하겠다.
- /kernel/에 `msg.h`와 `msg.c` 파일을 추가해 주도록 하자.
- 아래는 `msg.h` 이다.
~~~C
#ifndef KERNEL_MSG_H_
#define KERNEL_MSG_H_

#define MSG_Q_SIZE_BYTE 512

typedef enum KernelMsgQ_t
{
    KernelMsgQ_Task0,
    KernelMsgQ_Task1,
    KernelMsgQ_Task2,

    KernelMsgQ_Num
} KernelMsgQ_t;

typedef struct KernelCirQ_t
{
    uint32_t front;
    uint32_t rear;
    uint8_t Queue[MSG_Q_SIZE_BYTE]
} KernelCirQ_t;

void Kernel_msgQ_init(void);
bool Kernel_msgQ_is_empty(KernelMsgQ_t Qname);
bool Kernel_msgQ_is_full(KernelMsgQ_t Qname);
bool Kernel_msgQ_enqueue(KernelMsgQ_t Qname, uint8_t data);
bool Kernel_msgQ_dequeue(KernelMsgQ_t Qname, uint8_t* data);

#endif
~~~
- 큐의 정의에 따라 위에서 선언된 rear에서 데이터를 넣고 front에서 빼도록 한다.
	- rear의 인덱스에 변수가 들어가고, front의 인덱스에 있는 변수의 값을 가져온다.
- 기본으로 512바이트짜리 메시지 큐 세개를 선언했다.
	- 앞에서 선언한 태스크가 3개이기 때문에 한 태스크당 하나의 메시지큐를 선언.
- 다음은 메시지 큐의 전체 코드이다.
~~~C

~~~
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5MzkyMTY5MTcsMTI3ODcyMDQ4OCwtNT
U3NTg0OTUwXX0=
-->